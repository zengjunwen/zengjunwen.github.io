<!doctype html>
<html lang="zh-cn">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,minimum-scale=1" />
    <title>
        
      Tuning the JVM - Zjunwen
      
    </title>
    <meta name="keywords" content="Zjunwen" />
    
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:creator" content="@" />
      <meta property="og:url" content="15815193362338.html" />
      <meta property="og:title" content="Tuning the JVM" />
      
        <meta property="og:description" content="Tuning the JVM" />
      
      
        <meta property="og:image" content="https://zengjunwen.github.io/topicImage/TuningTheJVM.png" />
        <meta name="twitter:image" content="https://zengjunwen.github.io/topicImage/TuningTheJVM.png" />
      
      <meta property="og:site_name" content="Zjunwen" />
    
    
      <link rel="icon" href="media/15807816907881/æˆªå±2020-02-04ä¸Šåˆ10.39.45.png">
    
    <link href="atom.xml" rel="alternate" title="Zjunwen" type="application/atom+xml">
    <script src="https://cdn.bootcss.com/moment.js/2.24.0/moment.min.js"></script>
    <script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <link rel="stylesheet" href="asset/style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="head">
        <div class="row">
          <div class="col-md-12">
            <div class="blogname">Zjunwen</div>
            <nav>
              
                <div class="item"><a target="_self" href="index.html">Home</a></div>
              
                <div class="item"><a target="_self" href="archives.html">Archives</a></div>
              
                <div class="item"><a target="_blank" href="Arcade-Game/index.html">Game</a></div>
              
            </nav>
          </div>
        </div>
      </div>
      <hr>
    </div> <div class="container" id="post">
  <div class="article huge">
    <div class="featureimg" style="background-image: url('https://zengjunwen.github.io/topicImage/TuningTheJVM.png')"></div>
    <img src="https://zengjunwen.github.io/topicImage/TuningTheJVM.png" style="display: none;" class="featureimgforexternal">
    <div class="timeGTM" style="display:none;">2020-02-12T22:55:36+08:00</div>
    <div class="row content">
      <div class="col-md-2"></div>
      <div class="col-md-10 main">
        <div class="row">
          <div class="col-md-10">
            <div class="post">
              <div class="headline"><a href="15815193362338.html">Tuning the JVM</a></div>
              
              <div class="meta"><span class="time">$[timeformat('2020-02-12T22:55:36+08:00')]</span><br><span class="tags"></span></div>
              <div class="body">
                  <h2 id="toc_0">Outline</h2>

<p><img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-12%E4%B8%8B%E5%8D%8811.17.14.png" alt="æˆªå±2020-02-12ä¸‹åˆ11.17.14"/><br/>
The performance of interpreted bytecode still lags behind the performance of precompiled binary code. So in 1999, the JIT compiler was introduced and added to Sun&#39;s HotSpot JVM. The function of the JIT compiler is that during runtime, it identifies the parts of the application where the most time is spent executing bytecode, commonly known as hotspots, and then compiles the bytecode dynamically into machine code so that the program can run faster. The code is compiled just before execution, hence the name just-in-time, and is cached for future runs in the code cache. In this module, we&#39;ll talk about different types of JIT compilers in Java and how to choose a compilation mode. Then we&#39;ll look at the tuning flags for JIT compilation and what their effects are. Afterwards, we&#39;ll pivot to a detailed discussion of Java garbage collection. We&#39;ll discuss the different types of garbage collectors, how to monitor and measure garbage collection performance, and how to select and tune your garbage collector.</p>

<h2 id="toc_1">JIT Compilation Modes</h2>

<p>In the HotSpot JVM, there are two JIT compilers, compiler 1, commonly known as the C1 compiler, or the client compiler, and compiler 2, commonly known as the C2 compiler, or server compiler. The C1 compiler is intended to be used by client applications, so for that reason, it&#39;s optimized for startup performance. This means that it tries to find hot methods pretty early on, produces some basic, relatively unintrusive optimizations, and then compiles the method&#39;s bytecode to machine code. The C2 compiler is intended for use by server applications. The C2 compiler waits for a longer period of time before deciding to compile a hot method. This gives the compiler more time to learn about the method&#39;s execution pattern so that it can infer and apply more aggressive optimizations. As a result, methods compiled with C2 are generally faster than methods compiled with C1. However, because the C1 starts earlier than C2, an application running with the C1 compiler will be faster earlier on in its lifecycle before the C2 catches up and overtakes it. Therefore, if an application is short lived or sensitive to startup times, then the C1 compiler is actually a better choice for it. But what if you could combine the two? What if you could have an application start running, and then after some runs, the C1 compiler picks up a method and optimizes it get the intermediate performance benefit. And then at a later time, after some more runs, the method is reoptimized with the C2 compiler to get the faster machine code. This is exactly what the tiered compilation does. Tiered compilation is a compilation mode that was introduced in Java 7, and in tiered compilation, hot methods are first compiled with C1, and then as they get hotter, they are recompiled with C2. Although tiered compilation was introduced in Java 7, it wasn&#39;t until Java 8 that it became the default JIT compilation mode in the HotSpot JVM. The actual mechanism of tiered compilation is a bit complex, so I&#39;ll present a simplified version of it here. In tiered compilation, there are five execution levels. <br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8A%E5%8D%8812.02.34.png" alt="æˆªå±2020-02-13ä¸Šåˆ12.02.34"/></p>

<h2 id="toc_2">Definition of Hot Method</h2>

<p><img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8A%E5%8D%8812.07.16.png" alt="æˆªå±2020-02-13ä¸Šåˆ12.07.16"/></p>

<h2 id="toc_3">Garage Collection</h2>

<p>Garbage collection is the mechanism by which the JVM reclaims memory on behalf of the application when it&#39;s no longer needed. At a high level, it consists of finding objects that are no longer in use, freeing the memory associated with these objects, and occasionally compacting the heap to prevent memory fragmentation. <br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%889.22.06.png" alt="æˆªå±2020-02-13ä¸‹åˆ9.22.06"/><br/>
The garbage collector performs its work using one or more threads. But in order to do the job of tracking down object references and moving objects around in memory, it needs to make sure that the application threads are not currently using the objects because if, for example, an application thread is using an object and the memory location of the object changes due to GC, then bad and unpredictable things could happen. This is why garbage collection must pause all application threads while running. These pauses are sometimes called stop-the-world pauses, and the minimization of them is the primary concern of GC tuning, as they can have a huge impact on the performance of a Java application. <br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%889.22.30.png" alt="æˆªå±2020-02-13ä¸‹åˆ9.22.30"/><br/>
There are four main garbage collectors available in current JVMs. They are the serial collector; the parallel collector, which is also known as the throughput collector; the Concurrent Mark Sweep collector, or CMS collector; and the garbage first garbage collector, or G1GC.<br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%889.43.27.png" alt="æˆªå±2020-02-13ä¸‹åˆ9.43.27"/><br/>
The standard garbage collection architecture today is generational garbage collection, and all four aforementioned collectors are generational garbage collectors. Generational garbage collectors divide the heap into two areas, the young generation area and the old generation, or tenured area. The young generation itself is split into two logical areas, eden space, also known as the allocation space, and the survivor space. Finally, the survivor space is also split up into two, survivor space 0, S0, and survivor space 1, S1. <br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%8810.04.33.png" alt="æˆªå±2020-02-13ä¸‹åˆ10.04.33"/><br/>
Objects are created in the eden space of the young generation area, and when eden fills up, a minor garbage collection takes place. Minor GCs are optimized with the assumption that objects have a high mortality rate and are typically very fast. During the minor GC, objects are first checked to see if they&#39;re still reachable or not and then marked accordingly. Then reachable objects in eden have their age incremented and are then copied to a designated survivor space. Objects in the other survivor space also have their age incremented, and if they reach a certain threshold known as the tenured age, they get promoted to the tenured generation. But if they&#39;re under the tenured age, then they also get copied to the currently designated survivor space. Then both eden and the other survivor space are cleared, freeing the memory and compacting the space at the same time. The process is the same on the next minor GC run, but the survivor spaces switch roles, and the empty survivor space becomes the designated survivor space. Referenced objects are copied to this survivor space or tenured to the old generation, while eden and the other survivor space get cleared after the GC. And it goes back and forth from there. Eventually, the old generation also gets filled up and must be garbage collected. This is called a major, or full, garbage collection, and it usually takes up more time because the search space and number of objects is higher. This is where GC algorithms have their biggest differences. Basic collections will stop all application threads, mark the unreachable objects, free their memory, compact the heap, and then resume the application threads. Whereas more advanced collectors are able to scan for unreachable objects, even when the application threads are still running, and only pause all application threads to free the memory and compact the heap. These collectors are known as concurrent collectors, mostly concurrent collectors, or low-pause collectors. The Concurrent Mark Sweep and G1GC collectors are concurrent collectors, while the parallel collector is a basic collector.<br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%8810.06.20.png" alt="æˆªå±2020-02-13ä¸‹åˆ10.06.20"/><br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%8810.06.36.png" alt="æˆªå±2020-02-13ä¸‹åˆ10.06.36"/></p>

<h2 id="toc_4">Choosing a GC</h2>

<p>The serial collector is the simplest garbage collector available in HotSpot. It uses only one thread to process the heap, both for minor and major collections, and it&#39;ll stop all application threads while doing so. To enable the serial collector, use the +UseSerialGC flag. If your application will run on systems with only one processor or virtual processor and there are no pause time requirements, or if you&#39;re running a lot of small JVMs on a single machine, then you should use the serial collector. Another use case for the serial collector is if you have a small live set of data, up to appropriate 100 MB. In this case, using multiple threads to process the heap may not produce much of an advantage, especially considering the interthread communication overhead involved.<br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%8810.23.49.png" alt="æˆªå±2020-02-13ä¸‹åˆ10.23.49"/><br/>
In this case, using multiple threads to process the heap may not produce much of an advantage, especially considering the interthread communication overhead involved. For machines with multiple cores or 64-bit JVMs, <strong>the parallel collector is the default collector if you&#39;re running Java 7 or 8.</strong> The parallel collector uses multiple threads for minor and major collections and fully stops all application threads for both collections. This means that use of the parallel collector can result in long pause times of sometimes over a second, but overall, application throughput should be higher with the parallel collector than with a low-pause collector. Therefore, if you&#39;re running a non-interactive batch application where overall application performance is more important than low pause times, then you should go with this collector. If you&#39;re running Java 9 or later, then to enable to the parallel collector, you would set the +UseParallelGC flag. For Java 7 or 8, you shouldn&#39;t need this flag, as it&#39;s the default.<br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%8810.29.36.png" alt="æˆªå±2020-02-13ä¸‹åˆ10.29.36"/><br/>
As a concurrent collector, it&#39;s able to trace reachable objects and clean up unreachable ones all while live application threads are still running, allowing it achieve short GC pauses. However, since the GC threads run concurrently with application threads, the GC threads may compete with application threads for CPU resources. Therefore, a CPU-bound application may see a reduction in application throughput when GC threads are running.<br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%8810.32.50.png" alt="æˆªå±2020-02-13ä¸‹åˆ10.32.50"/><br/>
G1GC, which is the newer JVM concurrent collector, has been pegged as the replacement for the CMS collector, and since Java 9, the CMS collector has been marked as deprecated and will eventually be removed from the JVM code base. The garbage first garbage collector, G1GC, is the replacement for the CMS collector, and is the default collector in Java 9 and above. It&#39;s designed for multi-processor machines with large heaps, and it tries to achieve the best balance between latency and throughput. With G1GC, you can specify a goal for the maximum pause time you would want your application to encounter, and the collector will try to meet the requirement by trying to reclaim as much space as it can within the given constraints. G1GC is a mostly concurrent collector. G1GC threads mark unreachable objects concurrently while the application threads are running. This means that like the CMS collector, overhead from the concurrent execution may affect application throughput. Therefore, G1GC should be used if you have an interactive application, application response time is more important than overall throughput, and there&#39;s a requirement to keep pause times short.<br/>
<img src="media/15815193362338/%E6%88%AA%E5%B1%8F2020-02-13%E4%B8%8B%E5%8D%8810.35.41.png" alt="æˆªå±2020-02-13ä¸‹åˆ10.35.41"/></p>

<h2 id="toc_5">åƒåœ¾å›æ”¶ç®—æ³•:</h2>

<ol>
<li><p>æ ‡è®°-æ¸…é™¤ï¼šé¦–å…ˆæ ‡è®°å‡ºæ‰€æœ‰éœ€è¦å›æ”¶çš„å¯¹è±¡ï¼Œåœ¨æ ‡è®°å®Œæˆåç»Ÿä¸€å›æ”¶æ‰€æœ‰è¢«æ ‡è®°çš„å¯¹è±¡ã€‚<br/>
ä¸è¶³ï¼š</p>
<ul>
<li>æ•ˆç‡é—®é¢˜ï¼Œæ ‡è®°å’Œæ¸…é™¤ä¸¤ä¸ªè¿‡ç¨‹çš„æ•ˆç‡éƒ½ä¸é«˜ã€‚</li>
<li>ç©ºé—´é—®é¢˜ï¼Œæ ‡è®°æ¸…é™¤åä¼šäº§ç”Ÿå¤§é‡ä¸è¿ç»­çš„å†…å­˜ç¢ç‰‡ã€‚</li>
</ul></li>
<li><p>å¤åˆ¶ï¼šä¸ºäº†è§£å†³æ•ˆç‡é—®é¢˜ï¼Œå°†å†…å­˜æŒ‰ç…§å®¹é‡åˆ’åˆ†ä¸ºå¤§å°ç›¸ç­‰çš„ä¸¤å—ï¼Œæ¯æ¬¡åªä½¿ç”¨å…¶ä¸­çš„ä¸€å—ã€‚å½“è¿™å—å†…å­˜ç”¨å®Œäº†ï¼Œå°†è¿˜å­˜æ´»çš„å¯¹è±¡å¤åˆ¶åˆ°å¦ä¸€å—ä¸Šé¢ï¼Œç„¶åå†æŠŠå·²ä½¿ç”¨è¿‡çš„å†…å­˜ç©ºé—´ä¸€æ¬¡æ¸…ç†æ‰ï¼Œè¿™æ ·ä½¿å¾—æ¯æ¬¡éƒ½å¯¹æ•´ä¸ªåŠåŒºè¿›è¡Œå†…å­˜å›æ”¶ã€‚<br/>
ä¼˜ç‚¹ï¼šå®ç°ç®€å•ï¼Œè¿è¡Œé«˜æ•ˆã€‚<br/>
ä¸è¶³ï¼šä»£ä»·é«˜ï¼ˆå°†å†…å­˜ç¼©å°ä¸ºåŸæ¥çš„ä¸€åŠï¼‰</p></li>
<li><p>æ ‡è®°-æ•´ç†ï¼šé¦–å…ˆæ ‡è®°å‡ºæ‰€æœ‰éœ€è¦å›æ”¶çš„å¯¹è±¡ï¼Œç„¶åè®©æ‰€æœ‰å­˜æ´»çš„å¯¹è±¡éƒ½å‘ä¸€ç«¯ç§»åŠ¨ï¼Œç›´æ¥æ¸…ç†æ‰ç«¯è¾¹ç•Œä»¥å¤–çš„å†…å­˜ã€‚</p></li>
<li><p><strong>åˆ†ä»£æ”¶é›†</strong>ï¼šåœ¨æ–°ç”Ÿä»£ä¸­ï¼Œæ¯æ¬¡åƒåœ¾æ”¶é›†æ—¶éƒ½æœ‰å¤§é‡å¯¹è±¡æ­»å»ï¼Œåªæœ‰å°‘é‡å­˜æ´»ï¼Œé€‰ç”¨å¤åˆ¶ç®—æ³•ï¼Œåªéœ€è¦ä»˜å‡ºå°‘é‡å­˜æ´»å¯¹è±¡çš„å¤åˆ¶æˆæœ¬å°±å¯ä»¥å®Œæˆæ”¶é›†ã€‚è€Œè€å¹´ä»£ä¸­å› ä¸ºå¯¹è±¡å­˜æ´»ç‡é«˜ï¼Œæ²¡æœ‰é¢å¤–ç©ºé—´å¯¹å®ƒè¿›è¡Œåˆ†é…æ‹…ä¿ï¼Œä½¿ç”¨æ ‡è®°-æ¸…é™¤æˆ–æ ‡è®°-æ•´ç†ç®—æ³•æ¥è¿›è¡Œå›æ”¶ã€‚ï¼ˆä¸ºä»€ä¹ˆè¦åˆ†æ–°ç”Ÿä»£å’Œè€å¹´ä»£ï¼Ÿï¼‰</p></li>
</ol>

<h2 id="toc_6">JVMä¸­å †å’Œæ ˆçš„åŒºåˆ«</h2>

<p>æ ˆå†…å­˜ä¸»è¦ç”¨æ¥å­˜æ”¾åŸºæœ¬æ•°æ®ç±»å‹çš„å±€éƒ¨å˜é‡å’Œå¯¹è±¡çš„å¼•ç”¨å˜é‡ã€‚å †å†…å­˜ç”¨æ¥å­˜æ”¾è¿è¡Œæ—¶åˆ›å»ºçš„å¯¹è±¡ï¼Œé€šè¿‡newå…³é”®å­—åˆ›å»ºå‡ºæ¥çš„å¯¹è±¡éƒ½å­˜æ”¾åˆ°å †å†…å­˜ä¸­ã€‚</p>

<p>æ ˆå†…å­˜æ˜¯çº¿ç¨‹ç§æœ‰çš„ï¼Œç”Ÿå‘½å‘¨æœŸéšçº¿ç¨‹åˆ›å»ºè€Œåˆ›å»ºï¼Œéšçº¿ç¨‹ç»“æŸè€Œæ­»äº¡ã€‚å †å†…å­˜æ˜¯çº¿ç¨‹å…±äº«çš„ï¼Œå¤šçº¿ç¨‹è®¿é—®å †ä¸­çš„æ•°æ®æ—¶éœ€è¦å¯¹æ•°æ®è¿›è¡ŒåŒæ­¥ã€‚</p>

<p>æ ˆå†…å­˜çš„ç®¡ç†æ˜¯é€šè¿‡å‹æ ˆå’Œå¼¹æ ˆæ“ä½œæ¥å®Œæˆçš„ã€‚å †å†…å­˜çš„é‡Šæ”¾ç”±åƒåœ¾å›æ”¶å™¨æ¥è´Ÿè´£æ‰§è¡Œã€‚</p>

<p>æ ˆä¸»è¦ç”¨æ¥æ‰§è¡Œç¨‹åºçš„ï¼Œå †ä¸»è¦ç”¨æ¥å­˜æ”¾å¯¹è±¡çš„ã€‚</p>

<p>æ ˆçš„å­˜å–é€Ÿåº¦å¿«äºå †ã€‚</p>

<p>æ ˆçš„å¤§å°å’Œç”Ÿå­˜æœŸæ˜¯ç¡®å®šçš„ã€‚å †åœ¨è¿è¡Œæ—¶åŠ¨æ€åœ°åˆ†é…å†…å­˜å¤§å°ï¼Œç”Ÿå‘½å‘¨æœŸä¸ç¡®å®šã€‚</p>

              </div>
            </div>
            
            
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<script>
    let post = new Vue({
     el: '#post',
     data: {
       hidelikecoin: ''
     },
     methods: {
       timeformat(raw) {
         return moment(raw).format("YYYY å¹´ MM æœˆ DD æ—¥");
       }
     },
     delimiters: ['$[', ']']
   })
  </script>      <div class="container">
      <hr>
      <div class="footer" id="footer">
        <div class="slogan">æé—®ğŸ™‹ğŸ¼ã€æ€è€ƒğŸ¤”ã€ä¸“æ³¨ğŸ™‡ğŸ»ã€è§£å†³é—®é¢˜ğŸ’ğŸ»â€â™‚ï¸</div>
        <div class="meta">
          <p><p>ğŸ‘¨ğŸ»â€ğŸ’»<a href="https://github.com/zengjunwen" target="_blank">Github</a>  ğŸ“§<a href="mailto:junwenzeng@foxmail.com?subject=ã€ä»ä½ çš„åšå®¢è”ç³»åˆ°ä½ ã€‘&body=ä½ å¥½ï¼">eMail</a></p><p>é™¤ç‰¹æ®Šæ³¨æ˜å¤–ï¼Œåšå®¢æ‰€æœ‰æ–‡ç« ä½¿ç”¨CC-BY-NC-SAæˆæƒåè®®</p></p>
          <p>ã€ŒZjunwenã€</p>
        </div>
      </div>
      <script>
        let footer = new Vue({
          el: '#footer',
          data: {
            message: 'hello'
          },
          delimiters: ['$[', ']']
        })
      </script>
    </div>
  </div>
</body>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
<style></style>
</html>
